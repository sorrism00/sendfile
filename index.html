<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC P2P 파일 전송</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        #controls div { margin-bottom: 10px; }
        #log { border: 1px solid #ccc; padding: 10px; min-height: 100px; overflow-y: scroll; background-color: #f9f9f9; }
        button { padding: 8px 15px; margin-right: 5px; cursor: pointer; }
        input[type="text"], input[type="file"] { padding: 8px; width: 250px; }
        progress { width: 100%; height: 20px; }
    </style>
</head>
<body>
    <h1>WebRTC P2P 파일 전송</h1>

    <div id="controls">
        <div>
            <label for="roomIdInput">연결 코드 (Room ID):</label>
            <input type="text" id="roomIdInput" placeholder="Room ID 입력 또는 자동 생성" value="testroom123">
            <button id="createRoomBtn">새 연결 코드 생성</button>
        </div>

        <div>
            <button id="createOfferBtn">보내기 (Offer 생성)</button>
            <button id="connectReceiverBtn">받기 (Room ID로 연결)</button>
        </div>

        <div>
            <input type="file" id="fileInput">
            <button id="sendFileBtn" disabled>파일 전송 시작</button>
        </div>

        <div>
            <p>전송 상태: <span id="transferStatus">대기 중</span></p>
            <progress id="progressBar" value="0" max="100"></progress>
        </div>
        <div>
            <p>수신 파일: <a id="downloadLink" style="display:none;">다운로드</a></p>
        </div>
    </div>

    <h2>로그</h2>
    <pre id="log"></pre>

    <script>
        // --- GAS_WEB_APP_URL 설정 (중요!) ---
        // TODO: 아래 URL은 당신이 배포한 GAS 웹 앱의 실제 URL로 교체해야 합니다!
        // 현재는 이미지에서 확인된 URL을 붙여넣었습니다.
        const GAS_WEB_APP_URL = "https://script.google.com/macros/s/AKfycbwd9b7kpOoxilnHKquYwYj-qSD7palaNhlZb0PjFXT10Vje5uO-wgbUxHJHbmzNNDRn/exec";

        // ------------------------------------

        // --- WebRTC P2P 파일 전송 클라이언트 측 JavaScript 코드 ---

        const STUN_SERVERS = [{ urls: 'stun:stun.l.google.com:19302' }];
        const config = { iceServers: STUN_SERVERS };
        let peerConnection;
        let dataChannel;
        let currentFile = null; // 현재 선택된 파일 객체

        // UI 요소 참조
        const roomIdInput = document.getElementById('roomIdInput');
        const createRoomBtn = document.getElementById('createRoomBtn');
        const createOfferBtn = document.getElementById('createOfferBtn');
        const connectReceiverBtn = document.getElementById('connectReceiverBtn');
        const fileInput = document.getElementById('fileInput');
        const sendFileBtn = document.getElementById('sendFileBtn');
        const transferStatus = document.getElementById('transferStatus');
        const progressBar = document.getElementById('progressBar');
        const downloadLink = document.getElementById('downloadLink');
        const logElement = document.getElementById('log');

        /**
         * 로그 메시지를 UI에 추가하고 콘솔에 출력합니다.
         * @param {string} message - 출력할 메시지
         */
        function appendLog(message) {
            const now = new Date().toLocaleTimeString();
            logElement.textContent += `[${now}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight; // 스크롤을 최신 로그로 이동
            console.log(`[${now}] ${message}`); // 콘솔에도 출력하여 디버깅 용이하게
        }

        // --- GAS 시그널링 서버와 통신하는 함수 ---

        /**
         * GAS 웹 앱 시그널링 서버로 데이터를 전송합니다.
         * @param {string} roomId - 현재 룸 ID
         * @param {'offer'|'answer'|'iceCandidate'|'reset'} type - 시그널링 데이터 타입
         * @param {object} payload - 실제 시그널링 데이터 (SDP 또는 ICE 후보)
         * @param {object} [extra={}] - 추가로 전송할 데이터 (예: senderId, receiverId)
         * @returns {Promise<object>} - 서버 응답
         */
        async function sendDataToGasSignaling(roomId, type, payload, extra = {}) {
            const requestBody = { roomId, type, payload, ...extra };
            appendLog(`Sending ${type} to GAS for room ${roomId}`);
            try {
                const response = await fetch(GAS_WEB_APP_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }
                const result = await response.json();
                appendLog(`${type} sent. Result: ${JSON.stringify(result)}`);
                return result;
            } catch (error) {
                appendLog(`Error sending ${type} to GAS: ${error.message || error}`);
                console.error('Error sending data to GAS signaling server:', error);
                throw error;
            }
        }

        /**
         * GAS 웹 앱 시그널링 서버로부터 룸 데이터를 폴링합니다.
         * @param {string} roomId - 조회할 룸 ID
         * @returns {Promise<object>} - 룸의 현재 시그널링 데이터
         */
        async function getRoomDataFromGasSignaling(roomId) {
            // appendLog(`Polling room data for room ${roomId}`); // 너무 자주 로그 남는것 방지
            try {
                const response = await fetch(`${GAS_WEB_APP_URL}?roomId=${roomId}`);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }
                const data = await response.json();
                // appendLog(`Polled room data: ${JSON.stringify(data)}`);
                return data;
            } catch (error) {
                appendLog(`Error polling room data from GAS: ${error.message || error}`);
                console.error('Error polling room data from GAS signaling server:', error);
                throw error;
            }
        }

        // --- WebRTC 로직 ---

        /**
         * RTCPeerConnection 인스턴스를 초기화하고 이벤트 리스너를 설정합니다.
         * @param {string} role - 'sender' 또는 'receiver'
         * @param {string} roomId - 현재 룸 ID
         */
        function initializePeerConnection(role, roomId) {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            peerConnection = new RTCPeerConnection(config);
            appendLog(`PeerConnection initialized with role: ${role}`);

            // ICE 후보 생성 이벤트
            peerConnection.onicecandidate = async (event) => {
                if (event.candidate) {
                    appendLog(`Sending ICE candidate (${role}).`);
                    // ICE 후보는 toJSON() 메소드를 가지고 있습니다.
                    await sendDataToGasSignaling(roomId, 'iceCandidate', event.candidate.toJSON());
                }
            };

            // 연결 상태 변경 이벤트
            peerConnection.onconnectionstatechange = () => {
                appendLog(`PeerConnection state: ${peerConnection.connectionState}`);
                if (peerConnection.connectionState === 'connected') {
                    transferStatus.textContent = 'P2P 연결 수립 완료!';
                    if (role === 'sender') sendFileBtn.disabled = false;
                } else if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
                    transferStatus.textContent = 'P2P 연결 끊김/실패.';
                    sendFileBtn.disabled = true;
                    // 연결 끊김 시 정리 로직 추가 가능
                }
            };

            // 시그널링 상태 변경 이벤트 (디버깅용)
            peerConnection.onsignalingstatechange = () => {
                appendLog(`Signaling state: ${peerConnection.signalingState}`);
            };
        }

        // 전송자 로직 (Offer 생성)
        createOfferBtn.onclick = async () => {
            const roomId = roomIdInput.value.trim();
            if (!roomId) {
                alert('연결 코드를 입력하거나 생성해주세요.');
                return;
            }
            appendLog(`Creating offer for room: ${roomId}`);
            createRoomBtn.disabled = true;
            createOfferBtn.disabled = true;
            connectReceiverBtn.disabled = true; // sender는 receiver 버튼 비활성화

            initializePeerConnection("sender", roomId);

            // 데이터 채널 생성 (Sender가 파일을 보낼 것이므로)
            dataChannel = peerConnection.createDataChannel('file_transfer');
            setupDataChannelListeners(dataChannel, "sender");
            appendLog('DataChannel created (Sender).');

            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                // 수정: offer.toJSON() 대신 { type: offer.type, sdp: offer.sdp } 객체 전송
                await sendDataToGasSignaling(roomId, 'offer', { type: offer.type, sdp: offer.sdp }, { senderId: 'sender-' + Math.random().toString(36).substring(7) });

                transferStatus.textContent = `연결 코드 "${roomId}" 생성 완료. 수신자를 기다리는 중...`;
                // 주기적으로 Answer와 ICE 후보를 폴링
                pollSignalingData(roomId, "sender");
            } catch (error) {
                appendLog(`Error creating offer: ${error.message}`);
                console.error('Error creating offer:', error);
                transferStatus.textContent = `Offer 생성 실패: ${error.message}`;
                createOfferBtn.disabled = false; // 에러 시 다시 활성화
                createRoomBtn.disabled = false;
                connectReceiverBtn.disabled = false;
            }
        };

        // 수신자 로직 (Answer 생성)
        connectReceiverBtn.onclick = async () => {
            const roomId = roomIdInput.value.trim();
            if (!roomId) {
                alert('연결 코드를 입력해주세요.');
                return;
            }
            appendLog(`Connecting as receiver to room: ${roomId}`);
            createRoomBtn.disabled = true;
            createOfferBtn.disabled = true;
            connectReceiverBtn.disabled = true;

            initializePeerConnection("receiver", roomId);

            // IMPORTANT: ondatachannel must be set BEFORE setRemoteDescription for the receiver
            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                setupDataChannelListeners(dataChannel, "receiver");
                appendLog('DataChannel received (Receiver side).');
            };
            
            transferStatus.textContent = `연결 코드 "${roomId}"로 연결 시도 중...`;
            // 주기적으로 Offer와 ICE 후보를 폴링
            pollSignalingData(roomId, "receiver");
        };

        // DataChannel 이벤트 리스너 설정
        function setupDataChannelListeners(channel, role) {
            channel.onopen = () => {
                appendLog(`DataChannel ${channel.label} is open! (${role})`);
                if (peerConnection.connectionState === 'connected') { // P2P 연결이 완전히 수립되었을 때
                    transferStatus.textContent = 'P2P 연결 수립 완료!';
                    sendFileBtn.disabled = (role === "sender") ? false : true; // sender만 파일 전송 버튼 활성화
                }
            };
            channel.onclose = () => {
                appendLog(`DataChannel ${channel.label} is closed.`);
                transferStatus.textContent = 'P2P 연결 종료됨.';
                sendFileBtn.disabled = true;
            };
            channel.onerror = (error) => {
                appendLog(`DataChannel error: ${error.message || error}`);
                console.error('DataChannel error:', error);
                transferStatus.textContent = `오류 발생: ${error.message || error}`;
            };

            if (role === "sender") {
                channel.onmessage = (event) => {
                    // 수신자로부터의 ACK 메시지 등을 처리할 수 있습니다.
                    appendLog(`Sender received message: ${event.data}`);
                };
            } else if (role === "receiver") {
                let receivedChunks = [];
                let receivedFileName = '';
                let receivedFileType = '';
                let totalChunks = 0;
                let currentChunkIndex = 0;

                channel.onmessage = async (event) => {
                    if (typeof event.data === 'string') {
                        // 메타데이터 (파일 이름, 크기, 청크 수) 수신
                        try {
                            const metadata = JSON.parse(event.data);
                            if (metadata.type === 'file_metadata') {
                                receivedFileName = metadata.name;
                                receivedFileType = metadata.fileType; // MIME type
                                totalChunks = metadata.totalChunks;
                                receivedChunks = [];
                                currentChunkIndex = 0;
                                appendLog(`Receiving file: ${receivedFileName} (${totalChunks} chunks)`);
                                transferStatus.textContent = `파일 수신 중: ${receivedFileName}`;
                                progressBar.value = 0;
                                downloadLink.style.display = 'none';
                                downloadLink.removeAttribute('href');
                                downloadLink.removeAttribute('download');
                            } else if (metadata.type === 'file_end') {
                                 // 모든 청크 수신 완료
                                if (receivedChunks.length === totalChunks && totalChunks > 0) {
                                    appendLog('All file chunks received. Reassembling...');
                                    const blob = new Blob(receivedChunks, { type: receivedFileType || 'application/octet-stream' });
                                    const url = URL.createObjectURL(blob);
                                    downloadLink.href = url;
                                    downloadLink.download = receivedFileName;
                                    downloadLink.textContent = `다운로드: ${receivedFileName} (${(blob.size / (1024 * 1024)).toFixed(2)} MB)`;
                                    downloadLink.style.display = 'block';
                                    transferStatus.textContent = `파일 수신 완료! ${receivedFileName}`;
                                    appendLog(`File "${receivedFileName}" ready for download.`);
                                } else {
                                    appendLog(`Error: Mismatch in received chunks. Expected ${totalChunks}, got ${receivedChunks.length}`);
                                    transferStatus.textContent = `파일 수신 오류! (청크 불일치)`;
                                }
                            }
                        } catch (e) {
                            appendLog(`Error parsing metadata: ${e.message}, data: ${event.data}`);
                            console.error('Error parsing metadata:', e, event.data);
                            transferStatus.textContent = `메타데이터 오류: ${e.message}`;
                        }
                    } else {
                        // 파일 청크 데이터 수신
                        receivedChunks.push(event.data);
                        currentChunkIndex++;
                        progressBar.value = (currentChunkIndex / totalChunks) * 100;
                        transferStatus.textContent = `파일 수신 중: ${receivedFileName} (${currentChunkIndex}/${totalChunks} 청크)`;
                    }
                };
            }
        }

        // 파일 처리 및 전송 (Sender)
        const CHUNK_SIZE = 16 * 1024; // 16KB
        fileInput.onchange = (event) => {
            currentFile = event.target.files[0];
            if (currentFile) {
                appendLog(`Selected file: ${currentFile.name} (${(currentFile.size / (1024 * 1024)).toFixed(2)} MB)`);
                // P2P 연결이 완료된 상태에서만 전송 버튼 활성화
                if (dataChannel && dataChannel.readyState === 'open') {
                    sendFileBtn.disabled = false;
                }
            } else {
                sendFileBtn.disabled = true;
            }
        };

        sendFileBtn.onclick = async () => {
            if (!dataChannel || dataChannel.readyState !== 'open' || !currentFile) {
                alert('P2P 연결이 완료되지 않았거나 파일이 선택되지 않았습니다.');
                return;
            }

            appendLog('Starting file transfer...');
            transferStatus.textContent = '파일 메타데이터 전송 중...';
            sendFileBtn.disabled = true; // 전송 중 버튼 비활성화

            // 파일 메타데이터 전송
            const metadata = {
                type: 'file_metadata',
                name: currentFile.name,
                size: currentFile.size,
                fileType: currentFile.type,
                totalChunks: Math.ceil(currentFile.size / CHUNK_SIZE)
            };
            try {
                dataChannel.send(JSON.stringify(metadata));
                appendLog(`Sent file metadata: ${JSON.stringify(metadata)}`);

                let offset = 0;
                let chunkIndex = 0;

                while (offset < currentFile.size) {
                    const chunk = currentFile.slice(offset, offset + CHUNK_SIZE);
                    // DataChannel 버퍼가 가득 찼을 때 대기 (백프레셔 처리)
                    await new Promise(resolve => {
                        if (dataChannel.bufferedAmount > dataChannel.bufferedAmountLowThreshold + (CHUNK_SIZE * 5)) { // 버퍼가 너무 크면 잠시 대기
                            appendLog(`DataChannel buffer full (${dataChannel.bufferedAmount} bytes). Pausing...`);
                            const onBufferAmountLow = () => {
                                dataChannel.removeEventListener('bufferedamountlow', onBufferAmountLow);
                                resolve();
                            };
                            dataChannel.addEventListener('bufferedamountlow', onBufferAmountLow);
                        } else {
                            resolve();
                        }
                    });

                    dataChannel.send(chunk);
                    offset += chunk.size;
                    chunkIndex++;

                    progressBar.value = (offset / currentFile.size) * 100;
                    transferStatus.textContent = `파일 전송 중: ${currentFile.name} (${chunkIndex}/${metadata.totalChunks} 청크)`;
                }
                dataChannel.send(JSON.stringify({ type: 'file_end' })); // 파일 전송 완료 메시지
                transferStatus.textContent = `파일 전송 완료: ${currentFile.name}`;
                appendLog(`File "${currentFile.name}" transfer complete.`);
            } catch (error) {
                appendLog(`파일 전송 중 오류 발생: ${error.message}`);
                console.error('File transfer error:', error);
                transferStatus.textContent = `파일 전송 오류: ${error.message}`;
            } finally {
                sendFileBtn.disabled = false; // 전송 완료 또는 오류 시 버튼 다시 활성화
            }
        };

        // --- 시그널링 데이터 폴링 (정해진 시간마다 GAS 서버에 새 데이터 있는지 확인) ---
        let pollingIntervalId;
        let lastOffer = null; // 마지막으로 확인한 Offer
        let lastAnswer = null; // 마지막으로 확인한 Answer
        let lastIceCandidatesCount = 0; // 마지막으로 확인한 ICE 후보 개수

        /**
         * GAS 시그널링 서버에서 주기적으로 데이터를 폴링하고 WebRTC 연결에 적용합니다.
         * @param {string} roomId - 현재 룸 ID
         * @param {'sender'|'receiver'} role - 현재 피어의 역할
         */
        async function pollSignalingData(roomId, role) {
            if (pollingIntervalId) clearInterval(pollingIntervalId); // 기존 폴링 중지

            pollingIntervalId = setInterval(async () => {
                try {
                    const roomData = await getRoomDataFromGasSignaling(roomId);

                    if (roomData) {
                        // Offer 처리 (Receiver 역할일 때)
                        if (role === "receiver" && roomData.offer && JSON.stringify(roomData.offer) !== JSON.stringify(lastOffer)) {
                            appendLog('Received new Offer (Receiver).');
                            lastOffer = roomData.offer;
                            if (peerConnection && !peerConnection.remoteDescription) {
                                await peerConnection.setRemoteDescription(new RTCSessionDescription(roomData.offer));
                                const answer = await peerConnection.createAnswer();
                                await peerConnection.setLocalDescription(answer);
                                // 수정: answer.toJSON() 대신 { type: answer.type, sdp: answer.sdp } 객체 전송
                                await sendDataToGasSignaling(roomId, 'answer', { type: answer.type, sdp: answer.sdp }, { receiverId: 'receiver-' + Math.random().toString(36).substring(7) });
                                appendLog('Sent Answer (Receiver).');
                            }
                        }

                        // Answer 처리 (Sender 역할일 때)
                        if (role === "sender" && roomData.answer && JSON.stringify(roomData.answer) !== JSON.stringify(lastAnswer)) {
                            appendLog('Received new Answer (Sender).');
                            lastAnswer = roomData.answer;
                            if (peerConnection && !peerConnection.remoteDescription) {
                                await peerConnection.setRemoteDescription(new RTCSessionDescription(roomData.answer));
                                appendLog('Set Remote Description with Answer (Sender).');
                            }
                        }

                        // ICE 후보 처리 (두 역할 모두)
                        if (roomData.iceCandidates && roomData.iceCandidates.length > lastIceCandidatesCount) {
                            for (let i = lastIceCandidatesCount; i < roomData.iceCandidates.length; i++) {
                                const candidate = roomData.iceCandidates[i];
                                if (peerConnection) {
                                    try {
                                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                                        appendLog(`Added ICE candidate (${role}).`);
                                    } catch (e) {
                                        appendLog(`Error adding ICE candidate (${role}): ${e.message}`);
                                        console.error('Error adding received ICE candidate', e);
                                    }
                                }
                            }
                            lastIceCandidatesCount = roomData.iceCandidates.length;
                        }
                    }
                } catch (error) {
                    appendLog(`Polling error: ${error.message}`);
                    console.error('Error during polling:', error);
                }
            }, 3000); // 3초마다 폴링
        }


        // --- UI 보조 기능 ---

        /**
         * 새 연결 코드(Room ID)를 생성하여 입력 필드에 설정합니다.
         */
        createRoomBtn.onclick = () => {
            const newRoomId = 'room-' + Math.random().toString(36).substring(2, 9); // 임의의 문자열 생성
            roomIdInput.value = newRoomId;
            appendLog(`새 연결 코드 생성: ${newRoomId}`);
        };

    </script>
</body>
</html>